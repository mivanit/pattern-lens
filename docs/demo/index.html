<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <title>Attention Pattern Analysis</title>

    <!--
    #### ##     ## ########   #######  ########  ########  ######
     ##  ###   ### ##     ## ##     ## ##     ##    ##    ##    ##
     ##  #### #### ##     ## ##     ## ##     ##    ##    ##
     ##  ## ### ## ########  ##     ## ########     ##     ######
     ##  ##     ## ##        ##     ## ##   ##      ##          ##
     ##  ##     ## ##        ##     ## ##    ##     ##    ##    ##
    #### ##     ## ##         #######  ##     ##    ##     ######
    -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.2.31/vue.global.min.js"></script>
    <!-- Include lodash library for utility functions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <!-- Include pako library for decompressing SVGZ files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
    <!-- For decompressing SVGZ files -->
    <!-- Include ag-Grid library for prompts table -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/32.1.0/ag-grid-community.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@32.2.0/dist/ag-grid-community.min.js"></script>


    <!--
     ######   ######   ######
    ##    ## ##    ## ##    ##
    ##       ##       ##
    ##        ######   ######
    ##             ##       ##
    ##    ## ##    ## ##    ##
     ######   ######   ######
    -->
    <style>
        /* CSS Variables */
        :root {
            /* Colors */
            --primary: #007bff;
            --primary-hover: #0056b3;
            --secondary: #6c757d;
            --secondary-hover: #545b62;
            --success: #28a745;
            --border: #ccc;
            --text-muted: #666;
            --bg-light: #f0f0f0;
            --bg-white: #fff;
            --shadow: rgba(0, 0, 0, 0.1);

            /* Spacing */
            --space-xs: 3px;
            --space-sm: 5px;
            --space-md: 10px;
            --space-lg: 20px;

            /* Layout */
            --border-radius: 4px;
            --container-max-width: 1200px;
            --checkbox-size: 12px;
        }

        /* Base Styles */
        body {
            font-family: Arial, sans-serif;
            line-height: 1.4;
            margin: 0;
            padding: var(--space-md);
        }

        .container {
            max-width: var(--container-max-width);
            margin: 0 auto;
        }

        /* Layout Components */
        .main-selection-content {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            border: 2px solid var(--border);
            padding: var(--space-md);
            min-height: 300px;
            resize: vertical;
            overflow: auto;
        }

        .top-filters {
            display: flex;
            gap: var(--space-md);
            height: 350px;
        }

        /* Filter Components */
        .filters,
        .functions-filter {
            width: 180px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .functions-filter {
            width: 200px;
            flex-shrink: 0;
            border: 1px solid var(--border);
            padding: var(--space-md);
            border-radius: var(--border-radius);
        }

        .filter-item {
            margin-bottom: var(--space-sm);
            border: 1px solid var(--border);
            padding: var(--space-sm);
            border-radius: var(--border-radius);
        }

        .filter-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-xs);
        }

        .filter-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        /* Checkbox Lists */
        .checkbox-list {
            border: 1px solid var(--border);
            padding: var(--space-xs);
            flex: 1;
            overflow-y: auto;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 1px;
            line-height: 1;
        }

        input[type="checkbox"] {
            margin: 0 0.2em 0 0;
            width: var(--checkbox-size);
            height: var(--checkbox-size);
            vertical-align: middle;
        }

        /* Model Selection */
        .model-selection {
            flex: 1;
            border: 1px solid var(--border);
            padding: var(--space-md);
            border-radius: var(--border-radius);
        }

        .model-header {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            padding: 4px 0;
        }

        /* Head Grid */
        .head-grid {
            display: flex;
            gap: 1px;
            margin: 0 8px;
            height: 100%;
            align-items: center;
        }

        .grid-layer {
            display: flex;
            flex-direction: column;
            gap: 1px;
            height: 100%;
            justify-content: center;
        }

        .grid-cell {
            width: 3px;
            height: 3px;
            margin: 0.5px;
            transition: background-color 0.2s ease;
        }

        .grid-cell-selected {
            background-color: #4f46e5;
        }

        .grid-cell-empty {
            background-color: #e5e7eb;
        }

        /* Prompt Table */
        .prompt-table {
            flex-grow: 1;
            position: relative;
        }

        .prompts-info {
            border: 1px solid var(--border);
            padding: var(--space-sm);
            border-radius: var(--border-radius);
        }

        .prompt-counter {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .prompt-text-cell {
            cursor: pointer;
        }

        /* ag-Grid Specific */
        .ag-theme-alpine {
            height: calc(100% - 3em);
            width: 100%;
        }

        .ag-cell-edit-input {
            height: 100% !important;
            line-height: normal !important;
            padding: 0 8px !important;
        }

        .ag-cell:not(.invalid-selection) {
            background-color: transparent !important;
        }

        .ag-cell.invalid-selection {
            background-color: #ffeaea !important;
        }

        /* Dataset List */
        .dataset-list-container {
            position: absolute;
            right: var(--space-md);
            top: 0.5em;
        }

        .dataset-list {
            position: relative;
            cursor: pointer;
            border: 1px solid var(--border);
            padding: 1px;
            border-radius: var(--border-radius);
            background-color: #f9f9f9;
        }

        .dataset-list-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background-color: var(--bg-white);
            border: 1px solid var(--border);
            padding: var(--space-xs);
            padding-right: 3em;
            font-family: monospace;
            box-shadow: 0 4px 8px var(--shadow);
            z-index: 1000;
        }

        .dataset-list:hover .dataset-list-content {
            display: block;
        }

        /* Image Controls */
        .image-controls-container {
            margin: var(--space-lg) 0;
        }

        .image-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md);
            background-color: var(--bg-light);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .image-controls-display,
        .image-controls-size {
            display: flex;
            align-items: center;
            width: 50%;
        }

        .image-controls-size {
            justify-content: flex-end;
        }

        .resize-controls {
            display: flex;
            align-items: center;
        }

        .resize-slider {
            width: 250px;
            margin: 0 var(--space-md);
        }

        .resize-input {
            width: 75px;
            padding: 2px var(--space-sm);
        }

        /* Image Grid */
        .images {
            display: grid;
            gap: var(--space-sm);
            margin-top: var(--space-md);
        }

        .image-container {
            text-align: center;
        }

        .image-info {
            font-size: 0.8em;
            margin: 2em 0 -1em;
        }

        .img-container svg,
        .img-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--secondary-hover);
        }

        /* Progress Bar */
        .progress-bar {
            height: 12px;
            width: 200px;
            background: #ddd;
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .progress-bar-fill.loading {
            background-color: var(--primary);
        }

        .progress-bar-fill.complete {
            background-color: var(--success);
        }

        /* Utility Classes */
        .loading,
        .error {
            text-align: center;
            padding: var(--space-md);
        }

        .counter {
            font-size: 0.8em;
            color: var(--text-muted);
            margin-left: auto;
        }
    </style>
</head>

<body>
    <!--
    ##     ## ######## ##     ## ##
    ##     ##    ##    ###   ### ##
    ##     ##    ##    #### #### ##
    #########    ##    ## ### ## ##
    ##     ##    ##    ##     ## ##
    ##     ##    ##    ##     ## ##
    ##     ##    ##    ##     ## ########
    -->
    <!-- Root element for Vue app -->
    <div id="app" class="container">
        <h1>Attention Pattern Analysis</h1>

        <div class="main-selection-content">
            <!-- Top section with functions and models side by side -->
            <div class="top-filters">
                <!-- Functions Filter -->
                <div class="functions-filter">
                    <div class="filter-label">
                        <input type="checkbox" id="select-all-functions"
                            :indeterminate.prop="isIndeterminate('functions')" :checked="isChecked('functions')"
                            @change="toggleSelectAll('functions', $event)">
                        <label for="select-all-functions">Functions:</label>
                        <span class="counter">{{ selectedItems.functions.length }} / {{ items.functions.length }}</span>
                    </div>
                    <div class="checkbox-list">
                        <div v-for="func in items.functions" :key="func" class="checkbox-item">
                            <input type="checkbox" :id="'func-' + func" :value="func" v-model="selectedItems.functions">
                            <label :for="'func-' + func">{{ func }}</label>
                        </div>
                    </div>
                </div>

                <!-- Model Selection -->
                <div class="model-selection">
                    <div id="modelGrid" class="ag-theme-alpine" style="height: 300px; width: 100%;"></div>
                </div>
            </div>

            <!-- Prompts Table (full width) -->
            <div class="prompt-table">
                <div class="prompts-info">
                    <div class="prompt-counter">
                        Selected Prompts: {{ selectedPrompts.length }}
                    </div>
                    <div class="dataset-list-container">
                        <div class="dataset-list">
                            Hover here to see unique datasets
                            <div class="dataset-list-content">
                                <ul>
                                    <li v-for="dataset in uniqueDatasets" :key="dataset">{{ dataset }}</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="promptGrid" class="ag-theme-alpine"></div>
            </div>
        </div>

        <!-- image display button and size controls -->
        <div class="image-controls-container">
            <div class="image-controls">
                <div class="image-controls-display">
                    <button class="btn" :class="{ 'btn-primary': !imagesUpToDate, 'btn-secondary': imagesUpToDate }"
                        @click="displayImages">
                        {{ imagesUpToDate ? 'Images Up to Date' : 'Display Images' }}
                    </button>
                    <div class="progress-wrapper">
                        <span class="progress-status">{{ images.length }} / {{ totalExpectedImages }} images</span>
                        <div class="progress-bar" v-if="loading || images.length > 0">
                            <div class="progress-bar-fill" :class="{ 'loading': loading, 'complete': !loading }"
                                :style="{ width: `${(images.length / totalExpectedImages) * 100}%` }">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="image-controls-size" v-if="images.length > 0">
                    <label for="resizeSlider">Images per row:</label>
                    <input type="range" id="resizeSlider" class="resize-slider" v-model.number="imagesPerRow" min="1"
                        max="16" step="1">
                    <input type="number" class="resize-input" v-model.number="imagesPerRow" min="1" max="64">
                </div>
            </div>
        </div>

        <!-- images are loading -->
        <div v-if="loading" class="loading">Loading...</div>

        <!-- actual images display -->
        <div v-else-if="images.length > 0" class="images"
            :style="{ 'grid-template-columns': `repeat(${imagesPerRow}, 1fr)` }">
            <div v-for="image in images" class="image-container">
                <p v-if="imagesPerRow <= 4" class="image-info">
                    <a :href="getSinglePropertyFilterUrl('models', image.model)">{{ image.model }}</a> -
                    <a :href="getSinglePropertyFilterUrl('functions', image.function)">{{ image.function }}</a> -
                    <a :href="getSinglePropertyFilterUrl('layers', image.layer)">L{{ image.layer }}</a> -
                    <a :href="getSinglePropertyFilterUrl('heads', image.head)">H{{ image.head }}</a> -
                    <a :href="getSinglePropertyFilterUrl('prompts', image.promptHash)">{{ image.promptHash }}</a>
                </p>
                <a :href="getImageUrl(image)" class="img-container" v-html="image.content"
                    :title="imagesPerRow > 4 ? image.name : ''">
                </a>
            </div>
        </div>

        <!-- no images found -->
        <div v-else-if="imagesRequested" class="error">No images found for the selected criteria.</div>

    </div>

    <script>
        // Utility functions for file and directory operations
        //  ######   #######  ##    ##  ######  ########  ######        ## ####  #######
        // ##    ## ##     ## ###   ## ##    ##    ##    ##    ##      ##   ##  ##     ##
        // ##       ##     ## ####  ## ##          ##    ##           ##    ##  ##     ##
        // ##       ##     ## ## ## ##  ######     ##     ######     ##     ##  ##     ##
        // ##       ##     ## ##  ####       ##    ##          ##   ##      ##  ##     ##
        // ##    ## ##     ## ##   ### ##    ##    ##    ##    ##  ##       ##  ##     ##
        //  ######   #######  ##    ##  ######     ##     ######  ##       ####  #######
        const DATA_DIR = '.';
        const URL_PARAM_MAPPING = {
            models: 'selectedItems.models',
            functions: 'selectedItems.functions',
            prompts: 'selectedPrompts',
        };
        const FIGURE_FORMATS = ['svg', 'svgz', 'png'];
        const fileOps = {
            async getDirectoryContents(path) {
                const response = await fetch(`${path}/index.txt`);
                const text = await response.text();
                return text.trim().split('\n');
            },
            async fileExists(path) {
                const response = await fetch(path, { method: 'HEAD' });
                return response.ok;
            },
            async fetchJson(path) {
                const response = await fetch(path);
                return response.json();
            },
            async fetchJsonL(path) {
                const response = await fetch(path);
                const text = await response.text();
                // allow for the last line being incomplete
                const text_split = text.trim().split('\n');
                let output = text_split.slice(0, -1).map(JSON.parse);
                try {
                    output.push(JSON.parse(text_split[text_split.length - 1]));
                } catch (error) {
                    console.error('Error parsing last line of JSONL:', error);
                }
                return output;
            },
            async fetchAndDecompressSvgz(path) {
                // returns null if file does not exist
                const response = await fetch(path);
                if (!response.ok) {
                    return null;
                } else {
                    const arrayBuffer = await response.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    return pako.inflate(uint8Array, { to: 'string' });
                }
            },
            async figureExists(path) {
                for (const format of FIGURE_FORMATS) {
                    fig_path = `${path}.${format}`;
                    if (await this.fileExists(fig_path)) {
                        return format;
                    }
                }
                return null;
            }
        };
        // Create a new Vue.js application
        const app = Vue.createApp({

            // ########     ###    ########    ###
            // ##     ##   ## ##      ##      ## ##
            // ##     ##  ##   ##     ##     ##   ##
            // ##     ## ##     ##    ##    ##     ##
            // ##     ## #########    ##    #########
            // ##     ## ##     ##    ##    ##     ##
            // ########  ##     ##    ##    ##     ##

            data() {
                return {
                    // prompts
                    allPrompts: {}, // hash -> prompt
                    prompts: [], // for the current model
                    selectedPrompts: [], // selected from table
                    gridApi: null,
                    isGridReady: false,
                    // images
                    images: [],
                    totalExpectedImages: 0,
                    loading: false,
                    imagesRequested: false,
                    imagesUpToDate: false,
                    imagesPerRow: 4,
                    // filters
                    modelConfigs: {},
                    items: {
                        models: [],
                        functions: [],
                        layers: [],
                        heads: [],
                    },
                    selectedItems: {
                        models: [],
                        functions: [],
                        layers: [],
                        heads: [],
                    },
                    // head selection
                    headSelectionsRaw: {}, // model -> string mapping
                    headSelectionsParsed: {}, // model -> boolean[][] mapping for efficient lookup
                }
            },
            methods: {

                // ##     ## ########    ###    ########   ######
                // ##     ## ##         ## ##   ##     ## ##    ##
                // ##     ## ##        ##   ##  ##     ## ##
                // ######### ######   ##     ## ##     ##  ######
                // ##     ## ##       ######### ##     ##       ##
                // ##     ## ##       ##     ## ##     ## ##    ##
                // ##     ## ######## ##     ## ########   ######

                // Parse head selection string and return a 2D array of booleans
                parseHeadString(str, maxLayer, maxHead) {
                    try {
                        const result = Array(maxLayer).fill().map(() => Array(maxHead).fill(false));
                        if (!str || str.trim() === '') return result;

                        const selections = str.split(',').map(s => s.trim());

                        for (const selection of selections) {
                            const match = selection.match(/^L(\d+|\d+-\d+|\*)(H\d+|H\*|Hx)?$/);
                            if (!match) return null;

                            const layerPart = match[1];
                            let headPart = match[2];

                            // If the user typed only "L8" (no head specification), default to H*
                            if (!headPart) {
                                headPart = 'H*';
                            }

                            let layers = [];
                            if (layerPart === '*') {
                                layers = Array.from({ length: maxLayer }, (_, i) => i);
                            } else if (layerPart.includes('-')) {
                                const [start, end] = layerPart.split('-').map(Number);
                                if (start > end || end >= maxLayer) return null;
                                layers = Array.from({ length: end - start + 1 }, (_, i) => start + i);
                            } else {
                                const layer = Number(layerPart);
                                if (layer >= maxLayer) return null;
                                layers = [layer];
                            }

                            const headStr = headPart.substring(1);
                            if (headStr === '*' || headStr === 'x') {
                                for (const layer of layers) {
                                    result[layer].fill(true);
                                }
                            } else {
                                const head = Number(headStr);
                                if (head >= maxHead) return null;
                                for (const layer of layers) {
                                    result[layer][head] = true;
                                }
                            }
                        }

                        return result;
                    } catch (e) {
                        console.error('Error parsing head string:', e);
                        return null;
                    }
                },

                isHeadSelected(model, layer, head) {
                    // First check if we have parsed selections for this model
                    if (!this.headSelectionsParsed[model]) {
                        console.warn(`No parsed head selections found for model: ${model}`);
                        return false;
                    }

                    try {
                        // Verify layer and head are within bounds
                        const parsedSelections = this.headSelectionsParsed[model];
                        if (!Array.isArray(parsedSelections) ||
                            !Array.isArray(parsedSelections[layer]) ||
                            typeof parsedSelections[layer][head] === 'undefined') {
                            console.warn(
                                `Invalid layer/head combination for ${model}: L${layer}H${head}`,
                                `Max bounds: L${parsedSelections.length - 1}H${parsedSelections[0]?.length - 1}`
                            );
                            return false;
                        }

                        return parsedSelections[layer][head];
                    } catch (e) {
                        console.error('Error checking head selection:', e);
                        console.log('Model:', model, 'Layer:', layer, 'Head:', head);
                        return false;
                    }
                },

                isValidHeadSelection(model) {
                    return this.headSelectionsParsed[model] !== null;
                },

                updateHeadSelectionsParsed(model) {
                    const config = this.modelConfigs[model];
                    if (!config) {
                        console.warn(`No config found for model: ${model}`);
                        this.headSelectionsParsed[model] = null;
                        return;
                    }

                    const parsedHeads = this.parseHeadString(
                        this.headSelectionsRaw[model] || 'L*H*',
                        config.n_layers,
                        config.n_heads
                    );

                    if (!parsedHeads) {
                        console.warn(
                            `Invalid head selection for ${model}: "${this.headSelectionsRaw[model]}"`
                        );
                    }

                    this.headSelectionsParsed[model] = parsedHeads;
                },


                // ##     ## ########  ##
                // ##     ## ##     ## ##
                // ##     ## ##     ## ##
                // ##     ## ########  ##
                // ##     ## ##   ##   ##
                // ##     ## ##    ##  ##
                //  #######  ##     ## ########

                // Modified URL handling
                updateURL() {
                    const params = new URLSearchParams();

                    if (this.selectedItems.models.length > 0) {
                        params.set('models', this.selectedItems.models.join('~'));
                        params.set('headSelections', JSON.stringify(this.headSelectionsRaw));
                    }
                    if (this.selectedItems.functions.length > 0) {
                        params.set('functions', this.selectedItems.functions.join('~'));
                    }

                    if (this.selectedPrompts.length > 0) {
                        params.set('prompts', this.selectedPrompts.join('~'));
                    }

                    const newURL = `${window.location.pathname}?${params.toString()}`;
                    history.replaceState(null, '', newURL);
                },

                readURL() {
                    const params = new URLSearchParams(window.location.search);

                    this.selectedItems.models = params.get('models')?.split('~') || [];
                    this.selectedItems.functions = params.get('functions')?.split('~') || [];
                    this.selectedPrompts = params.get('prompts')?.split('~') || [];

                    try {
                        const headSelections = params.get('headSelections');
                        if (headSelections) {
                            const parsed = JSON.parse(headSelections);
                            this.headSelectionsRaw = parsed;
                            Object.keys(parsed).forEach(model => {
                                this.updateHeadSelectionsParsed(model);
                            });
                        }
                    } catch (e) {
                        console.error('Error parsing head selections from URL:', e);
                    }
                },
                selectPromptsFromURL() {
                    if (!this.isGridReady || this.selectedPrompts.length === 0) return;

                    const promptSet = new Set(this.selectedPrompts);
                    this.gridApi.forEachNode((node) => {
                        if (promptSet.has(node.data.hash)) {
                            node.setSelected(true);
                        }
                    });
                },
                getImageUrl(image) {
                    return this.getFilterUrl('all', [image.model], [image.promptHash], [image.layer], [image.head], [image.function]);
                },

                getSinglePropertyFilterUrl(type, value) {
                    const params = new URLSearchParams(window.location.search);
                    params.set(type, value); // This preserves other params while updating just this one
                    return `${window.location.pathname}?${params.toString()}`;
                },

                getFilterUrl(type, ...values) {
                    const params = new URLSearchParams(window.location.search);

                    if (type === 'all') {
                        params.set('models', values[0].join('~'));
                        params.set('prompts', values[1].join('~'));
                        params.set('layers', values[2].join('~'));
                        params.set('heads', values[3].join('~'));
                        params.set('functions', values[4].join('~'));
                    } else {
                        params.set(type, values.flat().join('~'));
                    }

                    return `${window.location.pathname}?${params.toString()}`;
                },

                // ##     ## ######## ##       ########  ######## ########
                // ##     ## ##       ##       ##     ## ##       ##     ##
                // ##     ## ##       ##       ##     ## ##       ##     ##
                // ######### ######   ##       ########  ######   ########
                // ##     ## ##       ##       ##        ##       ##   ##
                // ##     ## ##       ##       ##        ##       ##    ##
                // ##     ## ######## ######## ##        ######## ##     ##


                isIndeterminate(category) {
                    const items = this.items[category];
                    const selectedItems = this.selectedItems[category];
                    return selectedItems.length > 0 && selectedItems.length < items.length;
                },
                isChecked(category) {
                    const items = this.items[category];
                    const selectedItems = this.selectedItems[category];
                    return selectedItems.length === items.length && items.length > 0;
                },
                toggleSelectAll(category, event) {
                    const checked = event.target.checked;
                    this.selectedItems[category] = checked ? [...this.items[category]] : [];
                },
                async loadData() {
                    try {
                        await this.loadModels();
                        await Promise.all([
                            this.loadAllPrompts(),
                            this.loadFunctions()
                        ]);

                        this.updateLayersAndHeads();
                        this.updatePrompts(); // Update prompts after models and prompts are loaded
                    } catch (error) {
                        console.error('Error loading data:', error);
                    }
                },
                async loadModels() {
                    this.loading = true;
                    console.log('Loading models...');
                    const models = await fileOps.fetchJsonL(`${DATA_DIR}/models.jsonl`);
                    this.modelConfigs = {};
                    for (const model of models) {
                        this.modelConfigs[model["model_name"]] = model;
                    }
                    this.items.models = Object.keys(this.modelConfigs);
                    console.log('Models:', this.items.models);
                    this.loading = false;

                    // After loading models, initialize head selections
                    this.selectedItems.models.forEach(model => {
                        if (!this.headSelectionsRaw[model]) {
                            this.headSelectionsRaw[model] = 'L*H*';
                            this.updateHeadSelectionsParsed(model);
                        }
                    });
                },
                async loadFunctions() {
                    const functions = await fileOps.fetchJsonL(`${DATA_DIR}/functions.jsonl`);
                    console.log('Functions:', functions);
                    this.items.functions = functions.map(f => f.name);
                },
                onFirstDataRendered(params) {
                    this.selectPromptsFromURL();
                },
                // Handle selection change in ag-Grid
                onSelectionChanged() {
                    const selectedNodes = this.gridApi.getSelectedRows();
                    this.selectedPrompts = selectedNodes.map(node => node.hash);
                    this.updateURL();
                },
                // Update layers and heads based on selected models
                updateLayersAndHeads() {
                    // get all layer and head counts
                    let mdl_n_layers = [];
                    let mdl_n_heads = [];
                    for (const model of this.selectedItems.models) {
                        const config = this.modelConfigs[model];
                        if (config) {
                            mdl_n_layers.push(config.n_layers);
                            mdl_n_heads.push(config.n_heads);
                        }
                    }
                    // get the max layer and head counts, generate lists
                    this.items.layers = [];
                    this.items.heads = [];

                    for (let i = 0; i < _.max(mdl_n_layers); i++) {
                        this.items.layers.push(i.toString());
                    }
                    for (let i = 0; i < _.max(mdl_n_heads); i++) {
                        this.items.heads.push(i.toString());
                    }
                },

                // ##     ##  #######  ########  ######## ##        ######
                // ###   ### ##     ## ##     ## ##       ##       ##    ##
                // #### #### ##     ## ##     ## ##       ##       ##
                // ## ### ## ##     ## ##     ## ######   ##        ######
                // ##     ## ##     ## ##     ## ##       ##             ##
                // ##     ## ##     ## ##     ## ##       ##       ##    ##
                // ##     ##  #######  ########  ######## ########  ######
                getHeadSelectionCount(model) {
                    const parsed = this.headSelectionsParsed[model];
                    if (!parsed) return 0;
                    return parsed.reduce((acc, layer) =>
                        acc + layer.reduce((sum, isSelected) => sum + (isSelected ? 1 : 0), 0), 0);
                },
                getTotalHeads(model) {
                    const config = this.modelConfigs[model];
                    return config ? config.n_layers * config.n_heads : 0;
                },
                setupModelTable() {
                    const columnDefs = [
                        {
                            headerName: '',
                            field: 'selected',
                            width: 50,
                            checkboxSelection: true,
                            headerCheckboxSelection: true,
                            pinned: 'left'
                        },
                        {
                            headerName: 'Model',
                            field: 'model_name',
                            sort: 'asc',
                            width: 150
                        },
                        {
                            headerName: 'd_model',
                            field: 'd_model',
                            width: 90,
                            filter: 'agNumberColumnFilter'
                        },
                        {
                            headerName: 'n_layers',
                            field: 'n_layers',
                            width: 90,
                            filter: 'agNumberColumnFilter'
                        },
                        {
                            headerName: 'n_heads',
                            field: 'n_heads',
                            width: 90,
                            filter: 'agNumberColumnFilter'
                        },
                        {
                            headerName: 'Selected',
                            valueGetter: (params) => {
                                return `${this.getHeadSelectionCount(params.data.model_name)} / ${this.getTotalHeads(params.data.model_name)}`;
                            },
                            width: 100
                        },
                        {
                            headerName: 'Head Grid',
                            field: 'head_grid',
                            width: 150,
                            cellRenderer: (params) => {
                                const model = params.data.model_name;
                                const div = document.createElement('div');
                                div.className = 'head-grid';
                                div.setAttribute('data-model', model); // Add data attribute for updates

                                const n_heads = params.data.n_heads;
                                const n_layers = params.data.n_layers;

                                for (let h = 0; h < n_heads; h++) {
                                    const layerDiv = document.createElement('div');
                                    layerDiv.className = 'grid-layer';

                                    for (let l = 0; l < n_layers; l++) {
                                        const cell = document.createElement('div');
                                        cell.className = `grid-cell ${this.isHeadSelected(model, l, h) ? 'grid-cell-selected' : 'grid-cell-empty'}`;
                                        cell.setAttribute('data-layer', l);
                                        cell.setAttribute('data-head', h);
                                        layerDiv.appendChild(cell);
                                    }

                                    div.appendChild(layerDiv);
                                }

                                return div;
                            }
                        },
                        {
                            headerName: 'Head Selection',
                            field: 'head_selection',
                            editable: true,
                            width: 200,
                            cellEditor: 'agTextCellEditor',
                            cellEditorParams: {
                                maxLength: 50
                            },
                            valueSetter: params => {
                                const newValue = params.newValue;
                                const model = params.data.model_name;

                                // Update the head selection in Vue's data
                                params.context.componentParent.headSelectionsRaw[model] = newValue;
                                params.context.componentParent.updateHeadSelectionsParsed(model);

                                // Update the cell class for validation styling
                                const isValid = params.context.componentParent.isValidHeadSelection(model);
                                const cell = params.api.getCellRendererInstances({
                                    rowNodes: [params.node],
                                    columns: [params.column]
                                })[0];

                                if (cell) {
                                    const element = cell.getGui();
                                    if (isValid) {
                                        element.classList.remove('invalid-selection');
                                    } else {
                                        element.classList.add('invalid-selection');
                                    }
                                }

                                // Force refresh of the head grid cell
                                const gridCol = params.api.getColumnDef('head_grid');
                                if (gridCol) {
                                    params.api.refreshCells({
                                        rowNodes: [params.node],
                                        columns: ['head_grid'],
                                        force: true
                                    });
                                }

                                return true;
                            },
                            valueGetter: params => {
                                return params.context.componentParent.headSelectionsRaw[params.data.model_name] || 'L*H*';
                            },
                            cellClass: params => {
                                const isValid = params.context.componentParent.isValidHeadSelection(params.data.model_name);
                                return isValid ? '' : 'invalid-selection';
                            }
                        },
                    ];

                    const gridOptions = {
                        columnDefs: columnDefs,
                        rowData: Object.values(this.modelConfigs),
                        rowSelection: 'multiple',
                        suppressRowClickSelection: true,
                        defaultColDef: {
                            sortable: true,
                            filter: true,
                            resizable: true,
                            floatingFilter: true,
                            suppressKeyboardEvent: params => {
                                // Allow all keyboard events in edit mode
                                if (params.editing) {
                                    return false;
                                }
                                // Prevent default grid behavior for typing when not in edit mode
                                if (params.event.key.length === 1 && !params.event.ctrlKey && !params.event.metaKey) {
                                    return false;
                                }
                                return true;
                            },
                        },
                        context: {
                            componentParent: this
                        },
                        onSelectionChanged: (event) => {
                            const selectedRows = event.api.getSelectedRows();
                            this.selectedItems.models = selectedRows.map(row => row.model_name);
                        },
                        onGridReady: (params) => {
                            this.modelGridApi = params.api;
                            // Select models from URL
                            if (this.selectedItems.models.length > 0) {
                                params.api.forEachNode(node => {
                                    if (this.selectedItems.models.includes(node.data.model_name)) {
                                        node.setSelected(true);
                                    }
                                });
                            }
                        },
                    };

                    const gridDiv = document.querySelector('#modelGrid');
                    this.modelGridApi = agGrid.createGrid(gridDiv, gridOptions);
                },
                refreshHeadGrids() {
                    if (this.modelGridApi) {
                        this.modelGridApi.refreshCells({
                            columns: ['head_grid'],
                            force: true
                        });
                    }
                },
                // ########  ########   #######  ##     ## ########  ########  ######
                // ##     ## ##     ## ##     ## ###   ### ##     ##    ##    ##    ##
                // ##     ## ##     ## ##     ## #### #### ##     ##    ##    ##
                // ########  ########  ##     ## ## ### ## ########     ##     ######
                // ##        ##   ##   ##     ## ##     ## ##           ##          ##
                // ##        ##    ##  ##     ## ##     ## ##           ##    ##    ##
                // ##        ##     ##  #######  ##     ## ##           ##     ######

                async loadAllPrompts() {
                    this.loading = true;
                    console.log('Loading prompts...');
                    this.allPrompts = {};

                    for (const model of this.items.models) {
                        try {
                            const modelPrompts = await fileOps.fetchJsonL(`${DATA_DIR}/${model}/prompts.jsonl`);
                            for (const prompt of modelPrompts) {
                                if (prompt.hash in this.allPrompts) {
                                    this.allPrompts[prompt.hash].models.push(model);
                                } else {
                                    this.allPrompts[prompt.hash] = { ...prompt, models: [model] };
                                }
                            }
                        } catch (error) {
                            console.error(`Error loading prompts for model ${model}:`, error);
                        }
                    }
                    console.log('loaded number of prompts:', Object.keys(this.allPrompts).length);
                    this.loading = false;
                },
                updatePrompts() {
                    this.loading = true;
                    console.log('Selected models:', this.selectedItems.models);

                    // Use all models if none are selected
                    const selectedModelsTemp = this.selectedItems.models.length > 0 ? this.selectedItems.models : this.items.models;

                    // Filter prompts based on selected models
                    this.prompts = Object.values(this.allPrompts).filter(prompt =>
                        prompt.models.some(model => selectedModelsTemp.includes(model))
                    );

                    console.log('Prompts after filtering:', this.prompts.length);

                    // Update the grid data
                    if (this.gridApi) {
                        this.gridApi.setGridOption('rowData', this.prompts);
                    }

                    this.loading = false;
                },
                // Initialize the ag-Grid table
                setupPromptTable() {
                    const columnDefs = [
                        {
                            headerName: 'Prompt Text',
                            field: 'text',
                            sortable: true,
                            filter: true,
                            flex: 2,
                            cellRenderer: (params) => {
                                const eGui = document.createElement('div');
                                // Replace tabs and newlines with spaces for display
                                eGui.innerText = params.value.replace(/\s+/g, ' ');
                                eGui.classList.add('prompt-text-cell');
                                eGui.addEventListener('click', () => {
                                    navigator.clipboard.writeText(params.value);
                                });

                                eGui.addEventListener('contextmenu', (event) => {
                                    event.preventDefault();
                                    const newWindow = window.open();
                                    newWindow.document.write(`<pre>${params.value}</pre>`);
                                    newWindow.document.close();
                                    newWindow.document.title = `Prompt '${params.data.hash}'`;
                                });

                                return eGui;
                            },
                        },
                        {
                            headerName: 'Models', field: 'models', sortable: true, filter: true, width: 150,
                            valueFormatter: (params) => params.value.join(', '),
                        },
                        { headerName: 'Hash', field: 'hash', sortable: true, filter: true, width: 100 },
                        { headerName: 'Tokens', field: 'n_tokens', sortable: true, filter: 'agNumberColumnFilter', width: 80 },
                        { headerName: 'Dataset', field: 'meta.pile_set_name', sortable: true, filter: true, width: 150 },
                    ];

                    // Grid options
                    this.gridOptions = {
                        columnDefs: columnDefs,
                        rowData: this.prompts,
                        pagination: true,
                        enableCellTextSelection: true,
                        paginationPageSize: 20,
                        paginationPageSizeSelector: [5, 10, 20, 50, 100, 500],
                        selection: {
                            headerCheckbox: true,
                            selectAll: 'filtered',
                            checkboxes: true,
                            mode: 'multiRow',
                            enableClickSelection: true,
                        },

                        defaultColDef: {
                            sortable: true,
                            filter: true,
                            resizable: true,
                            floatingFilter: true
                        },
                        onSelectionChanged: this.onSelectionChanged.bind(this),
                        onFirstDataRendered: this.onFirstDataRendered.bind(this),
                        onGridReady: (params) => {
                            this.gridApi = params.api;
                            this.isGridReady = true;
                            this.selectPromptsFromURL();
                        },
                    };

                    const gridDiv = document.querySelector('#promptGrid');
                    this.gridApi = agGrid.createGrid(gridDiv, this.gridOptions);
                },

                // ########  ####  ######  ########  ##          ###    ##    ##
                // ##     ##  ##  ##    ## ##     ## ##         ## ##    ##  ##
                // ##     ##  ##  ##       ##     ## ##        ##   ##    ####
                // ##     ##  ##   ######  ########  ##       ##     ##    ##
                // ##     ##  ##        ## ##        ##       #########    ##
                // ##     ##  ##  ##    ## ##        ##       ##     ##    ##
                // ########  ####  ######  ##        ######## ##     ##    ##

                // Display images based on selected criteria
                async displayImages() {
                    this.loading = true;
                    this.imagesRequested = true;
                    this.images = [];

                    // Calculate total images based on parsed head selections
                    let totalImages = 0;
                    for (const model of this.selectedItems.models) {
                        totalImages += this.getHeadSelectionCount(model) * this.selectedPrompts.length * this.selectedItems.functions.length;
                    }
                    this.totalExpectedImages = totalImages;

                    // Load images based on parsed head selections
                    for (const model of this.selectedItems.models) {
                        const config = this.modelConfigs[model];
                        const rawString = this.headSelectionsRaw[model] || 'L*H*';
                        const parsedHeads = this.parseHeadString(rawString, config.n_layers, config.n_heads);
                        if (!parsedHeads) {
                            console.warn(`Invalid head selection for ${model}: "${rawString}"`);
                            continue;
                        }

                        // Iterate over all layers and heads
                        for (let layer = 0; layer < config.n_layers; layer++) {
                            for (let head = 0; head < config.n_heads; head++) {
                                if (!parsedHeads[layer][head]) {
                                    continue;
                                }
                                // Now for each selected prompt and function:
                                for (const promptHash of this.selectedPrompts) {
                                    for (const funcName of this.selectedItems.functions) {
                                        const basePath = `${DATA_DIR}/${model}/prompts/${promptHash}/L${layer}/H${head}`;
                                        const figure_format = await fileOps.figureExists(`${basePath}/${funcName}`);

                                        if (figure_format) {
                                            // Create figure entry
                                            const figure_meta = {
                                                name: `${model} - Prompt ${promptHash} - L${layer}H${head} - ${funcName}`,
                                                model: model,
                                                promptHash: promptHash,
                                                layer: layer,
                                                head: head,
                                                function: funcName,
                                                figure_format: figure_format,
                                            };

                                            if (figure_format === 'svgz') {
                                                const svgText = await fileOps.fetchAndDecompressSvgz(`${basePath}/${funcName}.svgz`);
                                                if (svgText) {
                                                    this.images.push({
                                                        content: svgText,
                                                        ...figure_meta,
                                                    });
                                                }
                                            } else {
                                                const imglink = `<img src="${basePath}/${funcName}.${figure_format}" alt="${figure_meta.name}">`;
                                                this.images.push({
                                                    content: imglink,
                                                    ...figure_meta,
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    this.imagesUpToDate = true;
                    this.loading = false;
                },
            },

            //  #######  ######## ##     ## ######## ########
            // ##     ##    ##    ##     ## ##       ##     ##
            // ##     ##    ##    ##     ## ##       ##     ##
            // ##     ##    ##    ######### ######   ########
            // ##     ##    ##    ##     ## ##       ##   ##
            // ##     ##    ##    ##     ## ##       ##    ##
            //  #######     ##    ##     ## ######## ##     ##

            computed: {
                uniqueDatasets() {
                    return [...new Set(this.prompts.map(prompt => prompt.meta.pile_set_name).filter(Boolean))];
                }
            },
            // Watch for changes in selected models to load prompts and update layers and heads
            watch: {
                'selectedItems': {
                    deep: true,
                    handler() {
                        this.imagesUpToDate = false;
                        this.updateURL();
                    }
                },
                selectedPrompts() {
                    this.imagesUpToDate = false;
                },
                headSelectionsRaw: {
                    deep: true,
                    handler(newValue) {
                        Object.keys(newValue).forEach(model => {
                            if (!this.modelConfigs[model]) {
                                console.warn(`Attempting to update head selections for unknown model: ${model}`);
                                return;
                            }
                            this.updateHeadSelectionsParsed(model);
                        });
                        this.imagesUpToDate = false;
                        this.updateURL();
                        this.refreshHeadGrids(); // Add this line to refresh the grids
                    }
                },
                'selectedItems.models': {
                    deep: true,
                    handler(newModels) {
                        // For newly selected models, make sure we have a default raw head selection string:
                        newModels.forEach(model => {
                            if (!this.headSelectionsRaw[model]) {
                                this.headSelectionsRaw[model] = 'L*H*';
                                this.updateHeadSelectionsParsed(model);
                            }
                        });
                        // Update prompts to reflect newly selected models
                        this.updatePrompts();
                        // Ensure the URL is up to date
                        this.updateURL();
                    }
                },
            },
            // Lifecycle hook when component is mounted
            async mounted() {
                this.readURL(); // Read filters from URL first
                await this.loadData(); // Load models, prompts, and functions
                this.setupModelTable(); // Initialize the model grid
                this.setupPromptTable(); // Initialize the prompts grid
            }
        });

        // Mount the Vue app to the DOM element with id="app"
        app.mount('#app');
    </script>
</body>

</html>