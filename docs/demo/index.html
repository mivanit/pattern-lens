<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <title>Attention Pattern Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.2.31/vue.global.min.js"></script>
    <!-- Include lodash library for utility functions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <!-- Include pako library for decompressing SVGZ files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
    <!-- For decompressing SVGZ files -->
    <!-- Include ag-Grid library for prompts table -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/32.1.0/ag-grid-community.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@32.2.0/dist/ag-grid-community.min.js"></script>
    <style>
        /* Base Styles */
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --primary-hover: #0056b3;
            --secondary-hover: #545b62;
            --border-color: #ccc;
            --light-bg: #f0f0f0;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --text-muted: #666;
            --success-color: #28a745;
            --border-radius: 4px;
            --spacing-xs: 3px;
            --spacing-sm: 5px;
            --spacing-md: 10px;
            --spacing-lg: 20px;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.4;
            margin: 0;
            padding: var(--spacing-md);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Layout Components */
        .main-selection-content {
            display: flex;
            gap: var(--spacing-md);
            border: 2px solid var(--border-color);
            padding: var(--spacing-md);
            resize: vertical;
            overflow: auto;
            min-height: 300px;
        }

        /* Filters Section */
        .filters {
            width: 180px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .model-function-filters {
            flex: 0 0 auto;
        }

        /* Layer and Head Filters */
        .layer-head-filters {
            display: flex;
            gap: var(--spacing-md);
            flex: 1;
            overflow: hidden;
            min-height: 0;
        }

        .layer-head-filters .filter-item {
            display: flex;
            flex-direction: column;
            width: 50%;
            box-sizing: border-box;
            overflow: hidden;
            height: 100%;
        }

        /* Filter Components */
        .filter-item {
            margin-bottom: var(--spacing-sm);
            border: 1px solid var(--border-color);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius);
        }

        .filter-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--spacing-xs);
        }

        .filter-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .counter {
            font-size: 0.8em;
            color: var(--text-muted);
            margin-left: auto;
        }

        .checkbox-list {
            border: 1px solid var(--border-color);
            padding: var(--spacing-xs);
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 1px;
            line-height: 1;
        }

        /* Form Elements */
        label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-size: 0.9em;
        }

        select {
            width: 100%;
            padding: 4px;
        }

        input[type="checkbox"] {
            margin-right: 0.2em;
            margin-top: 0;
            margin-bottom: 0;
            width: 12px;
            height: 12px;
            vertical-align: middle;
        }

        /* Prompt Table Components */
        .prompt-table {
            flex-grow: 1;
            position: relative;
        }

        .ag-theme-alpine {
            height: calc(100% - 3em);
            width: 100%;
        }

        .prompts-info {
            border: 1px solid var(--border-color);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius);
        }

        .prompt-counter {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .prompt-text-cell {
            cursor: pointer;
        }

        /* Dataset List */
        .dataset-list-container {
            position: absolute;
            right: 0;
            top: 0;
            margin-right: var(--spacing-md);
            margin-top: 0.5em;
        }

        .dataset-list {
            position: relative;
            cursor: pointer;
            border: 1px solid var(--border-color);
            padding: 1px;
            border-radius: var(--border-radius);
            background-color: #f9f9f9;
        }

        .dataset-list-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background-color: white;
            border: 1px solid var(--border-color);
            padding: var(--spacing-xs);
            padding-right: 3em;
            font-family: monospace;
            box-shadow: 0 4px 8px var(--shadow-color);
            z-index: 1000;
        }

        .dataset-list:hover .dataset-list-content {
            display: block;
        }

        /* Image Display Components */
        .image-controls-container {
            margin: var(--spacing-lg) 0;
        }

        .image-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md);
            background-color: var(--light-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .image-controls-display {
            display: flex;
            align-items: center;
            width: 50%;
            gap: var(--spacing-md);
        }

        .image-controls-size {
            display: flex;
            align-items: center;
            width: 50%;
            justify-content: flex-end;
        }

        .resize-controls {
            display: flex;
            align-items: center;
        }

        .resize-slider {
            width: 250px;
            margin: 0 var(--spacing-md);
        }

        .resize-input {
            width: 75px;
            padding: 2px var(--spacing-sm);
        }

        /* Button Styles */
        .btn {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--secondary-hover);
        }

        /* Progress Bar */
        .progress-bar {
            /* flex-grow: 1; */
            height: 12px;
            width: 200px;
            background: #ddd;
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .progress-bar-fill.loading {
            background-color: var(--primary-color);
        }

        .progress-bar-fill.complete {
            background-color: var(--success-color);
        }

        /* Image Grid */
        .images {
            display: grid;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        .image-container {
            text-align: center;
        }

        .image-info {
            font-size: 0.8em;
            margin-top: 2em;
            margin-bottom: -1em;
        }

        .img-container svg,
        .img-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }

        /* Utility Classes */
        .loading,
        .error {
            text-align: center;
            padding: var(--spacing-md);
        }

        /* Add new styles for head selection */
        .model-selection {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
        }
        
        .model-item {
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: var(--border-radius);
        }
        
        .model-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .model-info {
            color: var(--text-muted);
            font-size: 0.9em;
        }
        
        .head-input {
            width: 100%;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-top: 5px;
        }
        
        .head-input.error {
            border-color: #dc3545;
            background-color: #fff8f8;
        }
        
        .head-input:disabled {
            background-color: var(--light-bg);
            cursor: not-allowed;
        }

        .main-selection-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            border: 2px solid var(--border-color);
            padding: var(--spacing-md);
            min-height: 300px;
        }

        .top-filters {
            display: flex;
            gap: var(--spacing-md);
        }

        /* Functions filter */
        .functions-filter {
            width: 200px;
            flex-shrink: 0;  /* Prevent shrinking below 200px */
            border: 1px solid var(--border-color);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        /* Model selection */
        .model-selection {
            flex: 1;  /* Take up remaining space */
            border: 1px solid var(--border-color);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        /* Prompts section takes full width */
        .prompt-table {
            flex-grow: 1;
            position: relative;
        }
    </style>
</head>

<body>
    <!-- Root element for Vue app -->
    <div id="app" class="container">
        <h1>Attention Pattern Analysis</h1>

        <div class="main-selection-content">
            <!-- Top section with functions and models side by side -->
            <div class="top-filters">
                <!-- Functions Filter -->
                <div class="functions-filter">
                    <div class="filter-item">
                        <div class="filter-label">
                            <input type="checkbox" id="select-all-functions"
                                :indeterminate.prop="isIndeterminate('functions')"
                                :checked="isChecked('functions')"
                                @change="toggleSelectAll('functions', $event)">
                            <label for="select-all-functions">Functions:</label>
                            <span class="counter">{{ selectedItems.functions.length }} / {{ items.functions.length }}</span>
                        </div>
                        <div class="checkbox-list">
                            <div v-for="func in items.functions" :key="func" class="checkbox-item">
                                <input type="checkbox" :id="'func-' + func" :value="func" v-model="selectedItems.functions">
                                <label :for="'func-' + func">{{ func }}</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Model Selection -->
                <div class="model-selection">
                    <div v-for="model in items.models" :key="model" class="model-item">
                        <div class="model-header">
                            <input type="checkbox" 
                                   :id="'model-' + model" 
                                   :value="model" 
                                   v-model="selectedItems.models">
                            <label :for="'model-' + model">{{ model }}</label>
                            <span class="model-info">
                                ({{ modelConfigs[model].n_layers }} layers, 
                                {{ modelConfigs[model].n_heads }} heads)
                            </span>
                        </div>
                        <input type="text"
                               class="head-input"
                               :class="{ error: !isValidHeadSelection(model) }"
                               :disabled="!selectedItems.models.includes(model)"
                               v-model="headSelections[model]"
                               :placeholder="'e.g., L0H*, L1-3H0, L4H1'">
                    </div>
                </div>
            </div>

            <!-- Prompts Table (full width) -->
            <div class="prompt-table">
                <div class="prompts-info">
                    <div class="prompt-counter">
                        Selected Prompts: {{ selectedPrompts.length }}
                    </div>
                    <div class="dataset-list-container">
                        <div class="dataset-list">
                            Hover here to see unique datasets
                            <div class="dataset-list-content">
                                <ul>
                                    <li v-for="dataset in uniqueDatasets" :key="dataset">{{ dataset }}</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="promptGrid" class="ag-theme-alpine"></div>
            </div>
        </div>

        <!-- image display button and size controls -->
        <div class="image-controls-container">
            <div class="image-controls">
                <div class="image-controls-display">
                    <button class="btn" :class="{ 'btn-primary': !imagesUpToDate, 'btn-secondary': imagesUpToDate }"
                        @click="displayImages">
                        {{ imagesUpToDate ? 'Images Up to Date' : 'Display Images' }}
                    </button>
                    <div class="progress-wrapper">
                        <span class="progress-status">{{ images.length }} / {{ totalExpectedImages }} images</span>
                        <div class="progress-bar" v-if="loading || images.length > 0">
                            <div class="progress-bar-fill" :class="{ 'loading': loading, 'complete': !loading }"
                                :style="{ width: `${(images.length / totalExpectedImages) * 100}%` }">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="image-controls-size" v-if="images.length > 0">
                    <label for="resizeSlider">Images per row:</label>
                    <input type="range" id="resizeSlider" class="resize-slider" v-model.number="imagesPerRow" min="1"
                        max="16" step="1">
                    <input type="number" class="resize-input" v-model.number="imagesPerRow" min="1" max="64">
                </div>
            </div>
        </div>

        <!-- images are loading -->
        <div v-if="loading" class="loading">Loading...</div>

        <!-- actual images display -->
        <div v-else-if="images.length > 0" class="images"
            :style="{ 'grid-template-columns': `repeat(${imagesPerRow}, 1fr)` }">
            <div v-for="image in images" class="image-container">
                <p v-if="imagesPerRow <= 4" class="image-info">
                    <a :href="getSinglePropertyFilterUrl('models', image.model)">{{ image.model }}</a> -
                    <a :href="getSinglePropertyFilterUrl('functions', image.function)">{{ image.function }}</a> -
                    <a :href="getSinglePropertyFilterUrl('layers', image.layer)">L{{ image.layer }}</a> -
                    <a :href="getSinglePropertyFilterUrl('heads', image.head)">H{{ image.head }}</a> -
                    <a :href="getSinglePropertyFilterUrl('prompts', image.promptHash)">{{ image.promptHash }}</a>
                </p>
                <a :href="getImageUrl(image)" class="img-container" v-html="image.content"
                    :title="imagesPerRow > 4 ? image.name : ''">
                </a>
            </div>
        </div>

        <!-- no images found -->
        <div v-else-if="imagesRequested" class="error">No images found for the selected criteria.</div>

    </div>

    <script>
        // Utility functions for file and directory operations
        const DATA_DIR = '.';
        const URL_PARAM_MAPPING = {
            models: 'selectedItems.models',
            functions: 'selectedItems.functions',
            layers: 'selectedItems.layers',
            heads: 'selectedItems.heads',
            prompts: 'selectedPrompts',
        };
        const FIGURE_FORMATS = ['svg', 'svgz', 'png'];
        const fileOps = {
            async getDirectoryContents(path) {
                const response = await fetch(`${path}/index.txt`);
                const text = await response.text();
                return text.trim().split('\n');
            },
            async fileExists(path) {
                const response = await fetch(path, { method: 'HEAD' });
                return response.ok;
            },
            async fetchJson(path) {
                const response = await fetch(path);
                return response.json();
            },
            async fetchJsonL(path) {
                const response = await fetch(path);
                const text = await response.text();
                // allow for the last line being incomplete
                const text_split = text.trim().split('\n');
                let output = text_split.slice(0, -1).map(JSON.parse);
                try {
                    output.push(JSON.parse(text_split[text_split.length - 1]));
                } catch (error) {
                    console.error('Error parsing last line of JSONL:', error);
                }
                return output;
            },
            async fetchAndDecompressSvgz(path) {
                // returns null if file does not exist
                const response = await fetch(path);
                if (!response.ok) {
                    return null;
                } else {
                    const arrayBuffer = await response.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    return pako.inflate(uint8Array, { to: 'string' });
                }
            },
            async figureExists(path) {
                for (const format of FIGURE_FORMATS) {
                    fig_path = `${path}.${format}`;
                    if (await this.fileExists(fig_path)) {
                        return format;
                    }
                }
                return null;
            }
        };
        // Create a new Vue.js application
        const app = Vue.createApp({
            data() {
                return {
                    allPrompts: {}, // hash -> prompt
                    prompts: [], // for the current model
                    selectedPrompts: [], // selected from table
                    images: [],
                    totalExpectedImages: 0,
                    loading: false,
                    imagesRequested: false,
                    modelConfigs: {},
                    gridApi: null,
                    imagesPerRow: 4,
                    isGridReady: false,
                    items: {
                        models: [],
                        functions: [],
                        layers: [],
                        heads: [],
                    },
                    selectedItems: {
                        models: [],
                        functions: [],
                        layers: [],
                        heads: [],
                    },
                    imagesUpToDate: false,
                    headSelections: {}, // New property for head selections
                    validationCache: new Map(), // Cache for parsed head selections
                }
            },
            methods: {
                // New method to parse head selection string
                parseHeadString(str, maxLayer, maxHead) {
                    try {
                        const selections = str.split(',').map(s => s.trim());
                        const result = new Set();
                        
                        for (const selection of selections) {
                            const match = selection.match(/^L(\d+|\d+-\d+|\*)(H\d+|H\*|Hx)$/);
                            if (!match) return null;
                            
                            const [_, layerPart, headPart] = match;
                            
                            // Process layer part
                            let layers = [];
                            if (layerPart === '*') {
                                layers = Array.from({length: maxLayer}, (_, i) => i);
                            } else if (layerPart.includes('-')) {
                                const [start, end] = layerPart.split('-').map(Number);
                                if (start > end || end >= maxLayer) return null;
                                layers = Array.from({length: end - start + 1}, (_, i) => start + i);
                            } else {
                                const layer = Number(layerPart);
                                if (layer >= maxLayer) return null;
                                layers = [layer];
                            }
                            
                            // Process head part
                            const headStr = headPart.substring(1);
                            if (headStr === '*' || headStr === 'x') {
                                for (const layer of layers) {
                                    for (let head = 0; head < maxHead; head++) {
                                        result.add(`${layer},${head}`);
                                    }
                                }
                            } else {
                                const head = Number(headStr);
                                if (head >= maxHead) return null;
                                for (const layer of layers) {
                                    result.add(`${layer},${head}`);
                                }
                            }
                        }
                        
                        return Array.from(result);
                    } catch (e) {
                        return null;
                    }
                },

                // Validate head selection string
                isValidHeadSelection(model) {
                    const selection = this.headSelections[model];
                    if (!selection || !this.modelConfigs[model]) return true; // Empty or no config is considered valid
                    
                    const cacheKey = `${model}:${selection}`;
                    if (this.validationCache.has(cacheKey)) {
                        return this.validationCache.get(cacheKey);
                    }
                    
                    const config = this.modelConfigs[model];
                    const isValid = this.parseHeadString(selection, config.n_layers, config.n_heads) !== null;
                    this.validationCache.set(cacheKey, isValid);
                    return isValid;
                },
               // Modified URL handling
               updateURL() {
                    const params = new URLSearchParams();
                    
                    if (this.selectedItems.models.length > 0) {
                        params.set('models', this.selectedItems.models.join('~'));
                        params.set('headSelections', JSON.stringify(this.headSelections));
                    }
                    
                    if (this.selectedItems.functions.length > 0) {
                        params.set('functions', this.selectedItems.functions.join('~'));
                    }
                    
                    if (this.selectedPrompts.length > 0) {
                        params.set('prompts', this.selectedPrompts.join('~'));
                    }
                    
                    const newURL = `${window.location.pathname}?${params.toString()}`;
                    history.replaceState(null, '', newURL);
                },

                readURL() {
                    const params = new URLSearchParams(window.location.search);
                    
                    this.selectedItems.models = params.get('models')?.split('~') || [];
                    this.selectedItems.functions = params.get('functions')?.split('~') || [];
                    this.selectedPrompts = params.get('prompts')?.split('~') || [];
                    
                    try {
                        const headSelections = params.get('headSelections');
                        if (headSelections) {
                            this.headSelections = JSON.parse(headSelections);
                        }
                    } catch (e) {
                        console.error('Error parsing head selections from URL:', e);
                    }
                },
                isIndeterminate(category) {
                    const items = this.items[category];
                    const selectedItems = this.selectedItems[category];
                    return selectedItems.length > 0 && selectedItems.length < items.length;
                },
                isChecked(category) {
                    const items = this.items[category];
                    const selectedItems = this.selectedItems[category];
                    return selectedItems.length === items.length && items.length > 0;
                },
                toggleSelectAll(category, event) {
                    const checked = event.target.checked;
                    this.selectedItems[category] = checked ? [...this.items[category]] : [];
                },
                capitalizeLabel(str) {
                    return str.charAt(0).toUpperCase() + str.slice(1);
                },
                async loadData() {
                    try {
                        await this.loadModels();
                        await Promise.all([
                            this.loadAllPrompts(),
                            this.loadFunctions()
                        ]);

                        this.updateLayersAndHeads();
                        this.updatePrompts(); // Update prompts after models and prompts are loaded
                    } catch (error) {
                        console.error('Error loading data:', error);
                    }
                },
                async loadModels() {
                    this.loading = true;
                    console.log('Loading models...');
                    const models = await fileOps.fetchJsonL(`${DATA_DIR}/models.jsonl`);
                    this.modelConfigs = {};
                    for (const model of models) {
                        this.modelConfigs[model["model_name"]] = model;
                    }
                    this.items.models = Object.keys(this.modelConfigs);
                    console.log('Models:', this.items.models);
                    this.loading = false;
                    // After loading models, initialize head selections
                    this.selectedItems.models.forEach(model => {
                        if (!this.headSelections[model]) {
                            this.headSelections[model] = 'L*H*';
                        }
                    });
                },
                async loadAllPrompts() {
                    this.loading = true;
                    console.log('Loading prompts...');
                    this.allPrompts = {};

                    for (const model of this.items.models) {
                        try {
                            const modelPrompts = await fileOps.fetchJsonL(`${DATA_DIR}/${model}/prompts.jsonl`);
                            for (const prompt of modelPrompts) {
                                if (prompt.hash in this.allPrompts) {
                                    this.allPrompts[prompt.hash].models.push(model);
                                } else {
                                    this.allPrompts[prompt.hash] = { ...prompt, models: [model] };
                                }
                            }
                        } catch (error) {
                            console.error(`Error loading prompts for model ${model}:`, error);
                        }
                    }
                    console.log('loaded number of prompts:', Object.keys(this.allPrompts).length);
                    this.loading = false;
                },
                updatePrompts() {
                    this.loading = true;
                    console.log('Selected models:', this.selectedItems.models);

                    // Use all models if none are selected
                    const selectedModelsTemp = this.selectedItems.models.length > 0 ? this.selectedItems.models : this.items.models;

                    // Filter prompts based on selected models
                    this.prompts = Object.values(this.allPrompts).filter(prompt =>
                        prompt.models.some(model => selectedModelsTemp.includes(model))
                    );

                    console.log('Prompts after filtering:', this.prompts.length);

                    // Update the grid data
                    if (this.gridApi) {
                        this.gridApi.setGridOption('rowData', this.prompts);
                    }

                    this.loading = false;
                },
                async loadFunctions() {
                    const functions = await fileOps.fetchJsonL(`${DATA_DIR}/functions.jsonl`);
                    console.log('Functions:', functions);
                    this.items.functions = functions.map(f => f.name);
                },
                // Initialize the ag-Grid table
                setupPromptTable() {
                    const columnDefs = [
                        {
                            headerName: '✅❓',
                            field: 'selection',
                            headerCheckboxSelection: true,
                            headerCheckboxSelectionFilteredOnly: true,
                            checkboxSelection: true,
                            width: 100,
                            pinned: 'left',
                            comparator: (valueA, valueB, nodeA, nodeB, isInverted) => {
                                const selectedA = this.selectedPrompts.includes(nodeA.data.hash);
                                const selectedB = this.selectedPrompts.includes(nodeB.data.hash);
                                return selectedA === selectedB ? 0 : (selectedA ? -1 : 1);
                            },
                        },
                        {
                            headerName: 'Prompt Text',
                            field: 'text',
                            sortable: true,
                            filter: true,
                            flex: 2,
                            cellRenderer: (params) => {
                                const eGui = document.createElement('div');
                                // Replace tabs and newlines with spaces for display
                                eGui.innerText = params.value.replace(/\s+/g, ' ');
                                eGui.classList.add('prompt-text-cell');
                                eGui.addEventListener('click', () => {
                                    navigator.clipboard.writeText(params.value);
                                });

                                eGui.addEventListener('contextmenu', (event) => {
                                    event.preventDefault();
                                    const newWindow = window.open();
                                    newWindow.document.write(`<pre>${params.value}</pre>`);
                                    newWindow.document.close();
                                    newWindow.document.title = `Prompt '${params.data.hash}'`;
                                });

                                return eGui;
                            },
                        },
                        {
                            headerName: 'Models', field: 'models', sortable: true, filter: true, width: 150,
                            valueFormatter: (params) => params.value.join(', '),
                        },
                        { headerName: 'Hash', field: 'hash', sortable: true, filter: true, width: 100 },
                        { headerName: 'Tokens', field: 'n_tokens', sortable: true, filter: 'agNumberColumnFilter', width: 80 },
                        { headerName: 'Dataset', field: 'meta.pile_set_name', sortable: true, filter: true, width: 150 },
                    ];

                    // Grid options
                    this.gridOptions = {
                        columnDefs: columnDefs,
                        rowData: this.prompts,
                        pagination: true,
                        enableCellTextSelection: true,
                        paginationPageSize: 20,
                        paginationPageSizeSelector: [5, 10, 20, 50, 100, 500],
                        rowSelection: 'multiple',
                        defaultColDef: {
                            sortable: true,
                            filter: true,
                            resizable: true,
                            floatingFilter: true
                        },
                        onSelectionChanged: this.onSelectionChanged.bind(this),
                        onFirstDataRendered: this.onFirstDataRendered.bind(this),
                        onGridReady: (params) => {
                            this.gridApi = params.api;
                            this.isGridReady = true;
                            this.selectPromptsFromURL();
                        },
                        suppressRowClickSelection: true,
                    };

                    const gridDiv = document.querySelector('#promptGrid');
                    this.gridApi = agGrid.createGrid(gridDiv, this.gridOptions);
                },
                onFirstDataRendered(params) {
                    this.selectPromptsFromURL();
                },
                selectPromptsFromURL() {
                    if (!this.isGridReady || this.selectedPrompts.length === 0) return;

                    const promptSet = new Set(this.selectedPrompts);
                    this.gridApi.forEachNode((node) => {
                        if (promptSet.has(node.data.hash)) {
                            node.setSelected(true);
                        }
                    });
                },
                getImageUrl(image) {
                    return this.getFilterUrl('all', [image.model], [image.promptHash], [image.layer], [image.head], [image.function]);
                },

                getSinglePropertyFilterUrl(type, value) {
                    const params = new URLSearchParams(window.location.search);
                    params.set(type, value); // This preserves other params while updating just this one
                    return `${window.location.pathname}?${params.toString()}`;
                },

                getFilterUrl(type, ...values) {
                    const params = new URLSearchParams(window.location.search);

                    if (type === 'all') {
                        params.set('models', values[0].join('~'));
                        params.set('prompts', values[1].join('~'));
                        params.set('layers', values[2].join('~'));
                        params.set('heads', values[3].join('~'));
                        params.set('functions', values[4].join('~'));
                    } else {
                        params.set(type, values.flat().join('~'));
                    }

                    return `${window.location.pathname}?${params.toString()}`;
                },
                // Handle selection change in ag-Grid
                onSelectionChanged() {
                    const selectedNodes = this.gridApi.getSelectedRows();
                    this.selectedPrompts = selectedNodes.map(node => node.hash);
                    this.updateURL();
                },
                // Update layers and heads based on selected models
                updateLayersAndHeads() {
                    // get all layer and head counts
                    let mdl_n_layers = [];
                    let mdl_n_heads = [];
                    for (const model of this.selectedItems.models) {
                        const config = this.modelConfigs[model];
                        if (config) {
                            mdl_n_layers.push(config.n_layers);
                            mdl_n_heads.push(config.n_heads);
                        }
                    }
                    // get the max layer and head counts, generate lists
                    this.items.layers = [];
                    this.items.heads = [];

                    for (let i = 0; i < _.max(mdl_n_layers); i++) {
                        this.items.layers.push(i.toString());
                    }
                    for (let i = 0; i < _.max(mdl_n_heads); i++) {
                        this.items.heads.push(i.toString());
                    }
                },
                // Display images based on selected criteria
                async displayImages() {
                    this.loading = true;
                    this.imagesRequested = true;
                    this.images = [];
                    
                    // Calculate total images based on parsed head selections
                    let totalImages = 0;
                    for (const model of this.selectedItems.models) {
                        const config = this.modelConfigs[model];
                        const headSelection = this.headSelections[model] || 'L*H*';
                        const parsedHeads = this.parseHeadString(headSelection, config.n_layers, config.n_heads);
                        if (parsedHeads) {
                            totalImages += parsedHeads.length * this.selectedPrompts.length * this.selectedItems.functions.length;
                        }
                    }
                    this.totalExpectedImages = totalImages;

                    // Load images based on parsed head selections
                    for (const model of this.selectedItems.models) {
                        const config = this.modelConfigs[model];
                        const headSelection = this.headSelections[model] || 'L*H*';
                        const parsedHeads = this.parseHeadString(headSelection, config.n_layers, config.n_heads);
                        
                        if (!parsedHeads) continue;
                        
                        for (const [layer, head] of parsedHeads.map(h => h.split(','))) {
                            for (const promptHash of this.selectedPrompts) {
                                const basePath = `${DATA_DIR}/${model}/prompts/${promptHash}/L${layer}/H${head}`;
                                
                                for (const funcName of this.selectedItems.functions) {
                                    const figure_format = await fileOps.figureExists(`${basePath}/${funcName}`);
                                    
                                    if (figure_format) {
                                            const figure_meta = {
                                                name: `${model} - Prompt ${promptHash} - L${layer}H${head} - ${funcName}`,
                                                model: model,
                                                promptHash: promptHash,
                                                layer: layer,
                                                head: head,
                                                function: funcName,
                                                figure_format: figure_format,
                                            };


                                            if (figure_format === 'svgz') {
                                                // load and decompress svgz file, insert svg content inline
                                                const svgText = await fileOps.fetchAndDecompressSvgz(`${basePath}/${funcName}.svgz`);
                                                if (svgText) {
                                                    this.images.push({
                                                        content: svgText,
                                                        ...figure_meta,
                                                    });
                                                }
                                            }
                                            else {
                                                // content is a link to the image
                                                const imglink = `<img src="${basePath}/${funcName}.${figure_format}" alt="${figure_meta.name}">`;
                                                this.images.push({
                                                    content: imglink,
                                                    ...figure_meta,
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    this.imagesUpToDate = true;
                    this.loading = false;
                },
            },
            computed: {
                uniqueDatasets() {
                    return [...new Set(this.prompts.map(prompt => prompt.meta.pile_set_name).filter(Boolean))];
                }
            },
            // Watch for changes in selected models to load prompts and update layers and heads
            watch: {
                'selectedItems': {
                    deep: true,
                    handler() {
                        this.imagesUpToDate = false;
                        this.updateURL();
                    }
                },
                selectedPrompts() {
                    this.imagesUpToDate = false;
                },
                'selectedItems.models'() {
                    this.updatePrompts();
                    this.updateLayersAndHeads();
                    this.updateURL();
                },
                // selectedPrompts handled in onSelectionChanged
                'selectedItems.models'(newModels) {
                    // Initialize head selections for newly selected models
                    newModels.forEach(model => {
                        if (!this.headSelections[model]) {
                            this.headSelections[model] = 'L*H*';
                        }
                    });
                    this.updatePrompts();
                    this.updateURL();
                },
                'headSelections': {
                    deep: true,
                    handler() {
                        this.validationCache.clear();
                        this.imagesUpToDate = false;
                        this.updateURL();
                    }
                },
            },
            // Lifecycle hook when component is mounted
            async mounted() {
                this.readURL(); // Read filters from URL first
                await this.loadData(); // Load models, prompts, and functions
                this.setupPromptTable(); // Initialize the grid
            }
        });

        // Mount the Vue app to the DOM element with id="app"
        app.mount('#app');
    </script>
</body>

</html>